//
// Created by Administrator on 2020/8/14 0014.
//


/*
 *常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
 * 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。
 * 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
 *
 * 整数常量：
 *     整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
 *     整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
 * 浮点常量：
 *      浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
 *      当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。
 * 字符常量：
 *      字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。
 *      字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。
 *      在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。
 * 转义序列码：
 *  \\	\ 字符
 *  \'	' 字符
 *  \"	" 字符
 *  \?	? 字符
 *  \a	警报铃声
 *  \b	退格键
 *  \f	换页符
 *  \n	换行符
 *  \r	回车
 *  \t	水平制表符
 *  \v	垂直制表符
 *  \ooo	一到三位的八进制数
 *  \xhh . . .	一个或多个数字的十六进制数
 *
 * 字符串常量：
 *      字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。
 *      您可以使用空格做分隔符，把一个很长的字符串常量进行分行。
 *
 * 定义常量：
 *      在 C 中，有两种简单的定义常量的方式：
 *          使用 #define 预处理器。
 *          使用 const 关键字。
 */


//FIXME #define 预处理器
// #define identifier value

#include "stdio.h"

#define LENGTH 10
#define WEIDTH 5
#define NEWLINE '\n'

void constant_test1() {
    int area;
    area = LENGTH * WEIDTH;
    printf("area = %d", area);
    printf("%c", NEWLINE);
}

//FIXME const 关键字
// const type variable = value;

void constant_test2() {
    int const LENGTH_1 = 4;
    int const WEIDTH_1 = 3;
    int area;
    area = LENGTH_1 * WEIDTH_1;
    printf("area = %d \n", area);
}

/*
 *
 * #define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，
 * 而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！
 *
 *
 * const 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。
 * define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。
 *      1、两者的区别
 *          (1) 编译器处理方式不同
 *              #define 宏是在预处理阶段展开。
 *              const 常量是编译运行阶段使用。
 *         (2) 类型和安全检查不同
 *              #define 宏没有类型，不做任何类型检查，仅仅是展开。
 *              const 常量有具体的类型，在编译阶段会执行类型检查。
 *        (3) 存储方式不同
 *              #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
 *              const常量会在内存中分配(可以是堆中也可以是栈中)。
 *        (4) const 可以节省空间，避免不必要的内存分配。 例如：
 *              #define NUM 3.14159 //常量宏
 *              const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
 *              double i = Num; //此时为Pi分配内存，以后不再分配！
 *              double I= NUM; //编译期间进行宏替换，分配内存
 *              double j = Num; //没有内存分配
 *              double J = NUM; //再进行宏替换，又一次分配内存！
 *         const 定义常量从汇编的角度来看，只是给出了对应的内存地址，
 *         而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），
 *         而 #define 定义的常量在内存中有若干个拷贝。
 *       (5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
 *       (6) 宏替换只作替换，不做计算，不做表达式求解;
 *          宏预编译时就替换了，程序运行时，并不分配内存。
 */